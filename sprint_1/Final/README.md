# A. Калькулятор

Задание связано с обратной польской нотацией. Она используется для парсинга арифметических выражений. Еще её иногда называют постфиксной нотацией.
В постфиксной нотации операнды расположены перед знаками операций.
Пример 1: 

3 4 +
будет равно 7, и означает 3 + 4 

Пример 2: 

12 5 /
Так как деление целочисленное, то в результате получим 2.
Пример 3: 

10 2 4 * -
будет равно 2, и означает 10 - 2 * 4 
Разберём последний пример подробнее:

Знак * стоит сразу после чисел 2 и 4, значит к ним нужно применить операцию, которую этот знак обозначает, то есть перемножить эти два числа. В результате получим 8.

После этого выражение приобретёт вид:

10 8 -

Операцию «минус» нужно применить к двум идущим перед ней числам, то есть 10 и 8. В итоге получаем 2.
Рассмотрим алгоритм более подробно. Для его реализации будем использовать стек.
Для вычисления значения выражения, записанного в обратной польской нотации, нужно считывать выражение слева направо и придерживаться следующих шагов:
Обработка входного символа:
Если на вход подан операнд, он помещается на вершину стека.
Если на вход подан знак операции, то эта операция выполняется над требуемым количеством значений из стека, взятых в порядке добавления. Результат выполненной операции помещается на вершину стека.
Если входной набор символов обработан не полностью, перейти к шагу 1.
После полной обработки входного набора символов результат вычисления выражения находится в вершине стека. Если в стеке осталось несколько чисел, то надо вывести только верхний элемент.
Замечание про отрицательные числа и деление: в этой задаче под делением понимается математическое целочисленное деление. Это значит, что округление всегда происходит вниз. А именно: если a / b = c, то b ⋅ c – это наибольшее число, которое не превосходит a и одновременно делится без остатка на b.
Например, -1 / 3 = -1. Будьте осторожны, в C++, Java и go, например, деление чисел работает иначе.
Формат ввода

В единственной строке дано выражение, записанное в обратной польской нотации. Числа и арифметические операции записаны через пробел.
На вход могут подаваться операции: +, -, *, / и числа, по модулю не превосходящие 10000.
Гарантируется, что значение промежуточных выражений в тестовых данных по модулю не больше 50000.
Формат вывода

Выведите единственное число — значение выражения.

Пример 1

Ввод
2 1 + 3 *
Вывод
9

Пример 2

Ввод
7 2 + 4 * 2 +
Вывод
38


# B. Циклы

В этом спринте вы изучили структуру данных Связный список.
В Связном списке можно, например, хранить дни недели. Вторник за понедельником, среда за вторником, и так далее.

Вам предстоит это выяснить!
В качестве второго задания финального проекта нужно написать программу, которая определяет, есть ли цикл в связном списке, при этом не изменяя самого списка. Вы не можете добавлять поля (в языках, которые это поддерживают) и менять существующие.
На вход функция принимает голову списка, на выходе должна выдать True, если в списке содержится цикл, иначе — False. Размер дополнительной памяти, к которой обращается функция, не должен превышать О(1).

### Примечания

Можно использовать только O(1) дополнительной памяти. 
При отправке нужно выбирать компилятор make и загружать решение в виде файла. Для всех языков программирования, кроме Java, файл может быть назван любым именем, кроме solution.py/cpp/go/js (расширение обязательно)
Для Java файл должен называться Solution.java

# C. Стековая Очередь

Рита вчера по дороге на работу задумалась: можно ли реализовать очередь с использованием стеков? 
На самом деле можно, и вам предстоит это сделать. 
Очередь должна поддерживать методы: 
put - добавляет элемент 
get - извлекает самый ранее добавленный элемент 
get_size - возвращает текущий размер очереди
Формат ввода

В первой строке записано n - количество команд, оно не превосходит 5000. В каждой из следующих n строк записана одна из команд: 
put value 
get 
get_size 
value - целое число, по модулю не превосходящее 1000.
Формат вывода

Выведите результат вызова методов. Если метод get вызывается для пустой очереди, нужно напечатать 'error'.

Пример 1

Ввод
5
put -9
get
put -3
put 2
get_size
Вывод
-9
2

Пример 2

Ввод
8
put -7
get
put 1
get
put -2
get
put 2
get_size
Вывод
-7
1
-2
1

Пример 3

Ввод
9
put -3
put 0
put 7
put 4
get_size
put -4
get_size
get
get_size
Вывод
4
5
-3
4

### Примечания

Основные требования к выполнению задания:
Должен быть соблюден принцип FIFO. 
В реализации очереди используются только стеки. 
Готовую очередь из стандартной библиотеки языка программирования использовать нельзя.
Постарайтесь, чтобы получившаяся очередь была эффективной. То есть амортизированная (средняя) стоимость каждой операции O(1). 
Количество стеков, которое вы можете задействовать в решении, не ограничено!
